// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package data

import (
	"context"

	"github.com/pgvector/pgvector-go"
)

const bookExists = `-- name: BookExists :one
SELECT EXISTS(SELECT 1 FROM rag.book WHERE id = $1)
`

func (q *Queries) BookExists(ctx context.Context, id int64) (bool, error) {
	row := q.db.QueryRow(ctx, bookExists, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createBook = `-- name: CreateBook :one
INSERT INTO rag.book (book_name, book_text)
VALUES (
    $1, $2
)
RETURNING id, book_name, book_text
`

type CreateBookParams struct {
	BookName string
	BookText string
}

func (q *Queries) CreateBook(ctx context.Context, arg CreateBookParams) (RagBook, error) {
	row := q.db.QueryRow(ctx, createBook, arg.BookName, arg.BookText)
	var i RagBook
	err := row.Scan(&i.ID, &i.BookName, &i.BookText)
	return i, err
}

const listBooks = `-- name: ListBooks :many
SELECT
    id,
    book_name
FROM rag.book
`

type ListBooksRow struct {
	ID       int64
	BookName string
}

func (q *Queries) ListBooks(ctx context.Context) ([]ListBooksRow, error) {
	rows, err := q.db.Query(ctx, listBooks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListBooksRow
	for rows.Next() {
		var i ListBooksRow
		if err := rows.Scan(&i.ID, &i.BookName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryBook = `-- name: QueryBook :many
SELECT
    id,
    passage_text,
    CAST(1 - (embedding <=> $2) AS REAL) AS similarity
FROM rag.book_passage
WHERE book_id = $1
ORDER BY embedding <=> $2
LIMIT $3
`

type QueryBookParams struct {
	BookID    int64
	Embedding pgvector.Vector
	Limit     int32
}

type QueryBookRow struct {
	ID          int64
	PassageText string
	Similarity  float32
}

func (q *Queries) QueryBook(ctx context.Context, arg QueryBookParams) ([]QueryBookRow, error) {
	rows, err := q.db.Query(ctx, queryBook, arg.BookID, arg.Embedding, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []QueryBookRow
	for rows.Next() {
		var i QueryBookRow
		if err := rows.Scan(&i.ID, &i.PassageText, &i.Similarity); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
